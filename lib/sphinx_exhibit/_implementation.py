# FIXME: Output capture.
# FIXME: Patch AbstractMovieWriter.saving.
#
# FIXME: Backreferences (as a rst directive) (perhaps from hunter?).
# FIXME: Generate notebook from the rst-generated html.
#
# FIXME: Upstream fix to sphinx-jinja.

import ast
from collections import namedtuple
import copy
from enum import Enum
import itertools
from lib2to3 import pygram
import re
from pathlib import Path
import shutil
import textwrap
import tokenize
import warnings

import docutils
from docutils.parsers import rst
from docutils.statemachine import ViewList
import matplotlib as mpl
import matplotlib.testing.decorators
from matplotlib import pyplot as plt
import sphinx
from sphinx.builders.dummy import DummyBuilder
from sphinx.environment import BuildEnvironment

from . import _parser, _util, __version__

# FIXME: Make these local to exec().
mpl.backend_bases.FigureCanvasBase.start_event_loop = (
    lambda self, timeout=0: None)
mpl.backend_bases.FigureManagerBase.show = (
    lambda self: None)

plt.switch_backend("agg")
_log = sphinx.util.logging.getLogger(__name__.split(".")[0])
_deletion_notice = """\
.. This file was autogenerated by sphinx-exhibit, and will be deleted in the
   next build.

"""


class Stage(Enum):
    RstGeneration, RstGenerated = range(2)


class Style(Enum):
    Native = "native"
    SG = "sphinx-gallery"
    None_ = "none"


class State(namedtuple("_State", "stage path_artefacts")):
    # Second argument is needed for (un)picklability.
    def __new__(cls, stage, path_artefacts=None):
        return super().__new__(cls, stage, path_artefacts or {})


def builder_inited(app):
    env = BuildEnvironment(app)
    env.exhibit_state = State(Stage.RstGeneration)
    env.find_files(app.config, DummyBuilder(app))
    exhibits = []
    for docname in env.found_docs:
        path = Path(env.doc2path(docname))
        contents = path.read_text()
        if contents.startswith(_deletion_notice):
            path.unlink()
    # Generation must happen after all the unlinking is done.
    rst.directives.register_directive("exhibit", Exhibit)
    for docname in env.found_docs:
        path = Path(env.doc2path(docname))
        try:
            contents = path.read_text()
        except FileNotFoundError:  # Could have been deleted just above.
            continue
        if re.search(r"\.\.\s+exhibit::\n", contents):
            env.prepare_settings(docname)
            docutils.core.publish_doctree(
                contents, source_path=path, settings_overrides={"env": env})
    app.env.exhibit_state = State(Stage.RstGenerated)
    rst.directives.register_directive("exhibit-source", ExhibitSource)
    rst.directives.register_directive("exhibit-block", ExhibitBlock)


def env_merge_info(app, env, docnames, other):
    env.exhibit_state.path_artefacts.update(other.exhibit_state.path_artefacts)


def split_text_and_code_blocks(src):
    tree = _parser.parse(src)

    def _inner():
        for i, node in enumerate(tree.children):
            if (node.type == pygram.python_symbols.simple_stmt
                    and node.children[0].type == pygram.token.STRING
                    # Exclude b- or f-strings, but not r-strings.
                    and not re.search(
                        r"""\A[^'"]*[bBfF]""", node.children[0].value)):
                # This is never the last node.
                tree.children[i + 1].prefix = (
                    node.prefix + tree.children[i + 1].prefix)
                yield ("text",
                       ast.literal_eval(
                           "".join(leaf.value for leaf in node.leaves())),
                       node.get_lineno())
            else:
                yield ("code", str(node), node.get_lineno())

    for tp, it_group in itertools.groupby(_inner(), lambda kv: kv[0]):
        _, strs, linenos = zip(*it_group)
        yield tp, "".join(strs), linenos[0]


def generate_rst(
        src_path, *, syntax_style=Style.Native, output_style=Style.Native):

    if syntax_style is Style.Native:
        with tokenize.open(src_path) as file:
            src = file.read()
        text_and_code_blocks = split_text_and_code_blocks(src)
    elif syntax_style is Style.SG:
        from sphinx_gallery.py_source_parser import (
            split_code_and_text_blocks as sg_split_text_and_code_blocks)
        _, text_and_code_blocks = sg_split_text_and_code_blocks(src_path)
    else:
        assert False

    paragraphs = []
    block_counter = itertools.count()
    capture_after_lines = []
    for tp, string, lineno in text_and_code_blocks:
        if tp == "text":
            paragraphs.append(string)
        elif tp == "code":
            if not string.strip():
                # Don't generate a code-block if the file ends with text.
                continue
            capture_after_lines.append(lineno + string.count("\n") - 1)
            paragraphs.append(".. exhibit-block:: {}"
                              .format(next(block_counter)))
            paragraphs.append(textwrap.indent(string, "   "))
        else:
            assert False

    return (_deletion_notice
            + ":orphan:\n"
            + "\n"
            + ".. exhibit-source::\n"
            # FIXME: Relative path here?
            + "   :source: {}\n".format(src_path)
            + "   :capture-after-lines: {}\n".format(
                " ".join(map(str, capture_after_lines)))
            + "   :output-style: {}\n".format(output_style.value)
            + "\n"
            + "\n\n".join(paragraphs))


class SourceGetterMixin(rst.Directive):
    def get_current_source(self):
        env = self.state.document.settings.env
        e_state = env.exhibit_state
        if e_state.stage is Stage.RstGeneration:
            # As long as Sphinx is not set up, we can retrive the current
            # source from current_source (and settings.env doesn't exist yet).
            return Path(self.state.document.current_source)
        elif e_state.stage is Stage.RstGenerated:
            # Once Sphinx is set up, we can retrieve the current source from
            # settings.env.docname; moreover, current_source becomes sometimes
            # invalid because Sphinx may insert elements with a source of
            # <generated>, <rst_prolog>, <rst_epilog>, etc.
            return Path(env.doc2path(env.docname))
        else:
            assert False


class Exhibit(SourceGetterMixin):
    option_spec = {
        "srcdir": rst.directives.unchanged_required,
        "destdir": rst.directives.unchanged_required,
        "syntax-style": Style,
        "output-style": Style,
    }
    has_content = True

    def get_src_and_dest_paths(self):
        cur_dir = self.get_current_source().parent
        src_dir = cur_dir / self.options["srcdir"]
        src_paths = []
        for line in self.content:
            if line.startswith("!"):
                excluded = sorted(src_dir.glob(line[1:]))
                for path in excluded:
                    try:
                        src_paths.remove(path)
                    except ValueError:
                        pass
            else:
                if line.startswith(r"\!"):
                    line = line[1:]
                added = sorted(src_dir.glob(line))
                src_paths.extend(added)
        dest_dir = cur_dir / self.options["destdir"]
        return [(src_path,
                 (dest_dir / src_path.relative_to(src_dir))
                 # FIXME: Respect suffixes.
                 .with_suffix(".rst"))
                for src_path in src_paths]

    def run(self):
        self.options.setdefault("syntax-style", Style.Native)
        self.options.setdefault("output-style", Style.Native)

        env = self.state.document.settings.env
        e_state = env.exhibit_state
        if e_state.stage is Stage.RstGeneration:
            for src_path, dest_path in self.get_src_and_dest_paths():
                dest_path.parent.mkdir(parents=True, exist_ok=True)
                _util.ensure_contents(
                    dest_path,
                    generate_rst(
                        src_path,
                        syntax_style=self.options["syntax-style"],
                        output_style=self.options["output-style"]))
                # FIXME: Also arrange to delete this file.
                shutil.copyfile(src_path, dest_path.parent / src_path.name)
            return []
        elif e_state.stage is Stage.RstGenerated:
            cur_dir = self.get_current_source().parent
            vl = ViewList([
                "* :doc:`{}`".format(
                    dest_path.relative_to(cur_dir).with_suffix(""))
                for src_path, dest_path in self.get_src_and_dest_paths()
            ])
            node = rst.nodes.Element()
            self.state.nested_parse(vl, 0, node)
            return node.children
        else:
            assert False


class ExhibitSource(SourceGetterMixin):
    option_spec = {
        "source": rst.directives.unchanged_required,
        "capture-after-lines": rst.directives.positive_int_list,
        "output-style": Style,
    }
    has_content = True

    def run(self):
        self.options.setdefault("output-style", Style.Native)
        self.options["capture-after-lines"] = (  # Not None.
            self.options["capture-after-lines"] or [])

        e_state = self.state.document.settings.env.exhibit_state
        block_dests = e_state.path_artefacts[self.get_current_source()] = [
            [] for _ in self.options["capture-after-lines"]]

        if self.options["output-style"] is Style.None_:
            return []

        with tokenize.open(self.options["source"]) as file:
            mod = ast.parse(file.read())
        body = [(stmt.lineno, stmt) for stmt in mod.body]
        inserted = ast.parse("_sphinx_exhibit_export_()").body[0]
        insertions = []
        for lineno in self.options["capture-after-lines"]:
            stmt = copy.deepcopy(inserted)
            ast.increment_lineno(stmt, lineno - 1)
            insertions.append((lineno + .5, stmt))
        mod.body = [stmt for lineno, stmt in sorted(body + insertions,
                                                    key=lambda kv: kv[0])]
        code = compile(mod, self.options["source"], "exec")

        sg_base_num = 0

        def _sphinx_exhibit_export_(
                *, _block_counter=itertools.count()):
            nonlocal sg_base_num
            block_idx = next(_block_counter)
            for fig_idx, fignum in enumerate(plt.get_fignums()):
                if self.options["output-style"] is Style.Native:
                    dest = Path("{}-{}-{}.png".format(
                        self.get_current_source(), block_idx, fig_idx))
                elif self.options["output-style"] is Style.SG:
                    dir_path = self.get_current_source().parent / "images"
                    dir_path.mkdir(exist_ok=True)
                    dest = Path(
                        dir_path / "sphx_glr_{}_{:03}.png".format(
                            Path(self.state.document.settings.env.docname).name
                            .replace("/", "_"),
                            sg_base_num + fignum))
                else:
                    assert False
                block_dests[block_idx].append(dest)
                plt.figure(fignum).savefig(dest)
            sg_base_num += len(plt.get_fignums())
            # FIXME: Make this configurable?
            plt.close("all")

        # FIXME: chdir is only for SG compatibility.
        # FIXME: Also patch sys.argv.
        # Prevent Matplotlib's cleanup decorator from destroying the warnings
        # filters.
        try:
            with _util.chdir_cm(Path(self.options["source"]).parent), \
                    warnings.catch_warnings():
                mpl.testing.decorators.cleanup("default")(lambda: exec(
                    code,
                    {"_sphinx_exhibit_export_": _sphinx_exhibit_export_,
                     "__file__": self.options["source"]}))()
        # FIXME: Report error.
        except (Exception, SystemExit):
            pass
        return []


class ExhibitBlock(SourceGetterMixin):
    required_arguments = 1
    has_content = True

    def run(self):
        e_state = self.state.document.settings.env.exhibit_state
        current_source = self.get_current_source()
        paths = e_state.path_artefacts[current_source][int(self.arguments[0])]
        vl = ViewList(
            [".. code-block:: python", ""]
            + ["   " + line for line in self.content]
            + [""]
            + [".. image:: {}".format(path.relative_to(current_source.parent))
               for path in paths])
        node = rst.nodes.Element()
        self.state.nested_parse(vl, 0, node)
        return node.children


def setup(app):
    app.connect("builder-inited", builder_inited)
    app.connect("env-merge-info", env_merge_info)
    return {"version": __version__,
            "parallel_read_safe": True,
            "parallel_write_safe": True}
